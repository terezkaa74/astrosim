<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asteroid Impact Simulator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #0a0e27;
      color: #e0e6ed;
      overflow: hidden;
    }

    #scene3d {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(15, 23, 42, 0.92);
      backdrop-filter: blur(10px);
      padding: 24px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      z-index: 10;
      max-width: 380px;
      min-width: 320px;
    }

    #ui h2 {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #f1f5f9;
      letter-spacing: -0.02em;
    }

    #ui .subtitle {
      font-size: 13px;
      color: #94a3b8;
      margin-bottom: 20px;
    }

    #ui input {
      width: 100%;
      padding: 10px 14px;
      margin-bottom: 12px;
      background: rgba(30, 41, 59, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      color: #e0e6ed;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    #ui input:focus {
      outline: none;
      border-color: rgba(59, 130, 246, 0.6);
      background: rgba(30, 41, 59, 1);
    }

    #ui input::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    #ui button {
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    #ui button:hover {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    }

    #ui button:active {
      transform: translateY(0);
    }

    #output {
      margin-top: 16px;
      padding: 14px;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.6;
      max-height: 300px;
      overflow-y: auto;
      color: #94a3b8;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      display: none;
    }

    #output.active {
      display: block;
    }

    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(15, 23, 42, 0.92);
      backdrop-filter: blur(10px);
      padding: 16px 20px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 10;
      font-size: 13px;
      color: #94a3b8;
    }

    .loading {
      pointer-events: none;
      opacity: 0.6;
    }

    .loading::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }

    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }

    @media (max-width: 768px) {
      #ui {
        left: 10px;
        right: 10px;
        max-width: none;
      }

      #info {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="scene3d"></div>

  <div id="ui">
    <h2>Asteroid Impact Simulator</h2>
    <p class="subtitle">Visualize near-Earth object trajectories</p>
    <input id="neo-id" placeholder="NEO ID (e.g., 3542519)" value="3542519">
    <input id="diameter" type="number" placeholder="Diameter (meters)" value="200">
    <input id="velocity" type="number" placeholder="Velocity (m/s)" value="20000">
    <button id="run">Simulate Impact</button>
    <pre id="output"></pre>
  </div>

  <div id="info">
    Drag to rotate â€¢ Scroll to zoom
  </div>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0e27);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1e6, 1e13);
    camera.position.set(2e10, 1.5e10, 2e10);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById("scene3d").appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0x404060, 0.4);
    scene.add(ambientLight);

    const sunLight = new THREE.PointLight(0xffffff, 2);
    sunLight.position.set(-5e10, 0, 0);
    scene.add(sunLight);

    const earth = new THREE.Mesh(
      new THREE.SphereGeometry(6.371e9, 64, 64),
      new THREE.MeshPhongMaterial({
        color: 0x2266ff,
        transparent: true,
        opacity: 0.85,
        emissive: 0x112244,
        emissiveIntensity: 0.2
      })
    );
    scene.add(earth);

    const earthGlow = new THREE.Mesh(
      new THREE.SphereGeometry(6.8e9, 32, 32),
      new THREE.MeshBasicMaterial({
        color: 0x3388ff,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide
      })
    );
    scene.add(earthGlow);

    const sun = new THREE.Mesh(
      new THREE.SphereGeometry(7e9, 32, 32),
      new THREE.MeshBasicMaterial({ color: 0xffaa00 })
    );
    sun.position.set(-5e10, 0, 0);
    scene.add(sun);

    const sunGlow = new THREE.Mesh(
      new THREE.SphereGeometry(9e9, 32, 32),
      new THREE.MeshBasicMaterial({
        color: 0xffaa00,
        transparent: true,
        opacity: 0.3,
        side: THREE.BackSide
      })
    );
    sunGlow.position.copy(sun.position);
    scene.add(sunGlow);

    const stars = new THREE.Group();
    for (let i = 0; i < 1000; i++) {
      const star = new THREE.Mesh(
        new THREE.SphereGeometry(2e8, 4, 4),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
      );
      star.position.set(
        (Math.random() - 0.5) * 2e12,
        (Math.random() - 0.5) * 2e12,
        (Math.random() - 0.5) * 2e12
      );
      stars.add(star);
    }
    scene.add(stars);

    let trajectoryLine = null;
    let asteroidMesh = null;

    function createTrajectory(impactProb) {
      if (trajectoryLine) {
        scene.remove(trajectoryLine);
      }
      if (asteroidMesh) {
        scene.remove(asteroidMesh);
      }

      const points = [];
      const numPoints = 100;
      const radius = 1.5e11;

      for (let i = 0; i < numPoints; i++) {
        const t = i / numPoints;
        const angle = t * Math.PI * 2;
        const x = radius * Math.cos(angle) * (1 - t * 0.7);
        const y = radius * Math.sin(angle) * 0.3 * (1 - t * 0.5);
        const z = radius * Math.sin(angle) * (1 - t * 0.7);
        points.push(new THREE.Vector3(x, y, z));
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const color = impactProb > 0.5 ? 0xff4444 : 0xffaa00;
      trajectoryLine = new THREE.Line(
        geometry,
        new THREE.LineBasicMaterial({ color, linewidth: 2 })
      );
      scene.add(trajectoryLine);

      asteroidMesh = new THREE.Mesh(
        new THREE.SphereGeometry(3e8, 16, 16),
        new THREE.MeshPhongMaterial({ color: 0x888888, emissive: 0x442222 })
      );
      asteroidMesh.position.copy(points[0]);
      scene.add(asteroidMesh);

      let pointIndex = 0;
      const animateAsteroid = () => {
        if (asteroidMesh && pointIndex < points.length) {
          asteroidMesh.position.copy(points[pointIndex]);
          pointIndex = (pointIndex + 1) % points.length;
          setTimeout(animateAsteroid, 50);
        }
      };
      animateAsteroid();
    }

    async function simulate() {
      const button = document.getElementById('run');
      const output = document.getElementById('output');
      const neoId = document.getElementById('neo-id').value;
      const diameter = parseFloat(document.getElementById('diameter').value);
      const velocity = parseFloat(document.getElementById('velocity').value);

      button.classList.add('loading');
      button.textContent = 'Calculating trajectory';

      setTimeout(() => {
        const impactProb = Math.random();
        const energy = 0.5 * (diameter ** 3) * 3000 * (velocity ** 2) / 1e18;
        const craterDiameter = diameter * 20;

        createTrajectory(impactProb);

        const result = {
          neo_id: neoId,
          impact_probability: (impactProb * 100).toFixed(2) + '%',
          kinetic_energy: energy.toFixed(2) + ' TJ',
          estimated_crater: craterDiameter.toFixed(0) + ' meters',
          blast_radius: (craterDiameter * 3).toFixed(0) + ' meters',
          seismic_magnitude: (Math.log10(energy) + 2).toFixed(1),
          status: impactProb > 0.5 ? 'HIGH RISK' : 'LOW RISK'
        };

        output.textContent = JSON.stringify(result, null, 2);
        output.classList.add('active');
        button.textContent = 'Simulate Impact';
        button.classList.remove('loading');
      }, 1500);
    }

    document.getElementById('run').onclick = simulate;

    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let cameraAngle = { theta: Math.PI / 4, phi: Math.PI / 6 };
    let cameraDistance = 2.5e10;

    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;

        cameraAngle.theta -= deltaX * 0.005;
        cameraAngle.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngle.phi - deltaY * 0.005));

        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });

    renderer.domElement.addEventListener('mouseup', () => {
      isDragging = false;
    });

    renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault();
      cameraDistance *= (1 + e.deltaY * 0.001);
      cameraDistance = Math.max(1e10, Math.min(5e10, cameraDistance));
    }, { passive: false });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
      if (!isDragging) {
        cameraAngle.theta += 0.001;
      }

      camera.position.x = cameraDistance * Math.sin(cameraAngle.phi) * Math.cos(cameraAngle.theta);
      camera.position.y = cameraDistance * Math.cos(cameraAngle.phi);
      camera.position.z = cameraDistance * Math.sin(cameraAngle.phi) * Math.sin(cameraAngle.theta);
      camera.lookAt(0, 0, 0);

      earth.rotation.y += 0.001;
      earthGlow.rotation.y += 0.001;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
